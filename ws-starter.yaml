AWSTemplateFormatVersion: '2010-09-09'
Description: A stack that creates the resources required to complete the Amazon API Gateway WebSocket tutorial.

Parameters:
  StageName:
    Type: String
    Default: production

Resources:
  ConnectionsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      KeySchema:
        - AttributeName: id
          KeyType: HASH
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
  ConnectHandlerServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  ConnectHandlerServiceRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - dynamodb:BatchWriteItem
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:DeleteItem
              - dynamodb:DescribeTable
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - ConnectionsTable
                  - Arn
              - Ref: AWS::NoValue
        Version: "2012-10-17"
      PolicyName: ConnectHandlerServiceRoleDefaultPolicy
      Roles:
        - Ref: ConnectHandlerServiceRole
  ConnectHandler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |-
          import json
          import logging
          import os
          import boto3
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel("INFO")

          ddb_client = boto3.client('dynamodb')
          CONNECTION_SET_KEY = 'activeConnections'

          def lambda_handler(event, context):
              try:
                  params = event.get('queryStringParameters') or {}
                  conn_id = event['requestContext']['connectionId']
                  updates = {}

                  if params.get('type') == "cli" and params.get('cliId'):
                      updates[params['cliId']] = conn_id

                  if params.get('type') == "mpc" and params.get('mpcId'):
                      updates[params['mpcId']] = conn_id

                  if not updates:
                      logger.info("No valid parameters provided.")
                      return {'statusCode': 400, 'body': 'Missing cliId or mpcId'}

                  # Step 1: Ensure "items" map exists
                  ddb_client.update_item(
                      TableName=os.environ['TABLE_NAME'],
                      Key={"id": {"S": CONNECTION_SET_KEY}},
                      UpdateExpression="SET #items = if_not_exists(#items, :emptyMap)",
                      ExpressionAttributeNames={"#items": "items"},
                      ExpressionAttributeValues={":emptyMap": {"M": {}}}
                  )

                  # Step 2: Update items.<id> = conn_id
                  update_expr = "SET " + ", ".join([f"#items.#k{i} = :v{i}" for i in range(len(updates))])
                  expr_attr_names = {"#items": "items"}
                  expr_attr_values = {}

                  for i, (k, v) in enumerate(updates.items()):
                      expr_attr_names[f"#k{i}"] = k
                      expr_attr_values[f":v{i}"] = {"S": v}

                  ddb_client.update_item(
                      TableName=os.environ['TABLE_NAME'],
                      Key={"id": {"S": CONNECTION_SET_KEY}},
                      UpdateExpression=update_expr,
                      ExpressionAttributeNames=expr_attr_names,
                      ExpressionAttributeValues=expr_attr_values,
                  )

                  logger.info("Updated connection mapping: %s", json.dumps(updates))
                  return {'statusCode': 200}
              except Exception as e:
                  logger.error("Failed to update connections map: %s", e)
                  return {'statusCode': 500, 'body': str(e)}
      Role:
        Fn::GetAtt:
          - ConnectHandlerServiceRole
          - Arn
      Environment:
        Variables:
          TABLE_NAME:
            Ref: ConnectionsTable
      Handler: index.lambda_handler
      Timeout: 5
      Runtime: python3.12
    DependsOn:
      - ConnectHandlerServiceRoleDefaultPolicy
      - ConnectHandlerServiceRole
  DisconnectHandlerServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  DisconnectHandlerServiceRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - dynamodb:BatchWriteItem
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:DeleteItem
              - dynamodb:DescribeTable
            Effect: Allow
            Resource:
              - Fn::GetAtt:
                  - ConnectionsTable
                  - Arn
              - Ref: AWS::NoValue
        Version: "2012-10-17"
      PolicyName: DisconnectHandlerServiceRoleDefaultPolicy
      Roles:
        - Ref: DisconnectHandlerServiceRole
  DisconnectHandler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |-
          import json
          import logging
          import os
          import boto3
          from botocore.exceptions import ClientError

          logger = logging.getLogger()
          logger.setLevel("INFO")

          ddb_client = boto3.client('dynamodb')
          CONNECTION_SET_KEY = 'activeConnections'

          def lambda_handler(event, context):
              try:
                  conn_id = event['requestContext']['connectionId']
                  logger.info("Disconnecting connectionId: %s", conn_id)

                  # Get the current items map
                  response = ddb_client.get_item(
                      TableName=os.environ['TABLE_NAME'],
                      Key={"id": {"S": CONNECTION_SET_KEY}},
                      ProjectionExpression="items"
                  )

                  if 'Item' not in response or 'items' not in response['Item']:
                      logger.warning("No active connections found.")
                      return {'statusCode': 200}

                  items = response['Item']['items']['M']

                  # Find all keys that have this conn_id as value
                  keys_to_remove = [k for k, v in items.items() if v['S'] == conn_id]

                  if not keys_to_remove:
                      logger.info("No matching connectionId found.")
                      return {'statusCode': 200}

                  # Build remove expressions
                  update_expr = "REMOVE " + ", ".join([f"#items.#k{i}" for i in range(len(keys_to_remove))])
                  expr_attr_names = {"#items": "items"}
                  for i, key in enumerate(keys_to_remove):
                      expr_attr_names[f"#k{i}"] = key

                  ddb_client.update_item(
                      TableName=os.environ['TABLE_NAME'],
                      Key={"id": {"S": CONNECTION_SET_KEY}},
                      UpdateExpression=update_expr,
                      ExpressionAttributeNames=expr_attr_names
                  )

                  logger.info("Removed keys: %s", keys_to_remove)
                  return {'statusCode': 200}

              except Exception as e:
                  logger.error("Failed to clean up disconnected ID: %s", e)
                  return {'statusCode': 500, 'body': str(e)}
      Role:
        Fn::GetAtt:
          - DisconnectHandlerServiceRole
          - Arn
      Environment:
        Variables:
          TABLE_NAME:
            Ref: ConnectionsTable
      Handler: index.lambda_handler
      Runtime: python3.12
    DependsOn:
      - DisconnectHandlerServiceRoleDefaultPolicy
      - DisconnectHandlerServiceRole
  GetConnectionIdHandlerServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  GetConnectionIdHandler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |-
          import boto3
          import json
          import logging

          logger = logging.getLogger()
          logger.setLevel("INFO")

          def lambda_handler(event, context):
              logger.info("Received event: %s", json.dumps(event))
              try:
                  connection_id = event["requestContext"]["connectionId"]
                  domain = event["requestContext"]["domainName"]
                  stage = event["requestContext"]["stage"]

                  endpoint_url = f"https://{domain}/{stage}"
                  client = boto3.client("apigatewaymanagementapi", endpoint_url=endpoint_url)

                  response_body = {"connectionId": connection_id}

                  client.post_to_connection(
                      ConnectionId=connection_id,
                      Data=json.dumps(response_body).encode("utf-8")
                  )

                  return {"statusCode": 200, "body": "Connection ID sent"}
              except Exception as e:
                  logger.error("Failed to send connection ID: %s", e)
                  return {"statusCode": 500, "body": json.dumps({"error": str(e)})}
      Role: !GetAtt GetConnectionIdHandlerServiceRole.Arn
      Handler: index.lambda_handler
      Runtime: python3.12
  manageConnections:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Statement:
          - Action: execute-api:ManageConnections
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - "arn:aws:execute-api:"
                  - Ref: AWS::Region
                  - ":"
                  - Ref: AWS::AccountId
                  - ":"
                  - "*/*/POST/@connections/*"
        Version: "2012-10-17"
      PolicyName: manageConnections7F91357B
      Roles:
        - Ref: GetConnectionIdHandlerServiceRole
        - Ref: SendServerHandlerServiceRole
        - Ref: PingHandlerServiceRole
  WebSocketApi:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: WebSocketApi
      ProtocolType: WEBSOCKET
      RouteSelectionExpression: "$request.body.action"
  WebSocketApiDeployment:
    Type: AWS::ApiGatewayV2::Deployment
    DependsOn:
      - ConnectRoute
      - DisconnectRoute
    Properties:
      ApiId: !Ref WebSocketApi
  WebSocketApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      StageName: !Ref StageName
      DeploymentId: !Ref WebSocketApiDeployment
      ApiId: !Ref WebSocketApi
  ConnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${ConnectHandler.Arn}/invocations
      IntegrationMethod: POST
  DisconnectIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${DisconnectHandler.Arn}/invocations
      IntegrationMethod: POST
  MockIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: MOCK
  GetConnectionIdIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${GetConnectionIdHandler.Arn}/invocations
      IntegrationMethod: POST
  ConnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: "$connect"
      AuthorizationType: NONE
      Target: !Sub integrations/${ConnectIntegration}
  DisconnectRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: "$disconnect"
      AuthorizationType: NONE
      Target: !Sub integrations/${DisconnectIntegration}
  DefaultRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: "$default"
      AuthorizationType: NONE
      Target: !Sub integrations/${MockIntegration}
  GetConnectionIdRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: "getConnectionId"
      AuthorizationType: NONE
      Target: !Sub integrations/${GetConnectionIdIntegration}
  ConnectLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt ConnectHandler.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/$connect
  DisconnectLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt DisconnectHandler.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/$disconnect
  GetConnectionIdPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt GetConnectionIdHandler.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/getConnectionId
  SendServerHandlerServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: "2012-10-17"
      ManagedPolicyArns:
        - Fn::Join:
            - ""
            - - "arn:"
              - Ref: AWS::Partition
              - :iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  SendServerHandlerServiceRoleDefaultPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action:
              - dynamodb:PutItem
              - dynamodb:UpdateItem
              - dynamodb:GetItem
              - dynamodb:DescribeTable
            Resource:
              - Fn::GetAtt:
                  - ConnectionsTable
                  - Arn
      PolicyName: SendServerHandlerServiceRolePolicy
      Roles:
        - Ref: SendServerHandlerServiceRole
  SendServerHandler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |-
          import boto3
          import json
          import os
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          ddb = boto3.client("dynamodb")
          CONNECTION_SET_KEY = 'activeConnections'
          MAPPING_SET_KEY = "activeMapping"          

          def lambda_handler(event, context):
              try:
                  ddb.put_item(
                      TableName=os.environ["TABLE_NAME"],
                      Item={
                          "id": {"S": MAPPING_SET_KEY},
                          "mapping": {"M": {}}
                      },
                      ConditionExpression="attribute_not_exists(id)"
                  )
                  logger.info("Initialized activeMapping item")
              except ddb.exceptions.ConditionalCheckFailedException:
                  pass  # already exists

              try:
                  logger.info("Received event: %s", json.dumps(event))

                  body = json.loads(event.get("body", '{}'))
                  operation_type = body.get("operationType")
                  cli_to_mpc = body.get("cliToMpc")
                  message = body.get("message")

                  if not operation_type or not message:
                      return {"statusCode": 400, "body": json.dumps({"error": "Missing OperationType or Message"})}

                  # Step 1: If CliToMpc is present, update bidirectional mapping
                  if cli_to_mpc:
                      update_expr_parts = []
                      expr_attr_names = {"#mapping": "mapping"}
                      expr_attr_values = {}

                      for i, (cli_id, mpc_id) in enumerate(cli_to_mpc.items()):
                          # cli → mpc
                          cli_key = f"#cli{i}"
                          cli_val = f":mpc{i}"
                          update_expr_parts.append(f"#mapping.{cli_key} = {cli_val}")
                          expr_attr_names[cli_key] = cli_id
                          expr_attr_values[cli_val] = {"S": mpc_id}

                          # mpc → cli (reverse direction)
                          mpc_key = f"#mpc{i}"
                          mpc_val = f":cli{i}"
                          update_expr_parts.append(f"#mapping.{mpc_key} = {mpc_val}")
                          expr_attr_names[mpc_key] = mpc_id
                          expr_attr_values[mpc_val] = {"S": cli_id}

                      update_expr = "SET " + ", ".join(update_expr_parts)

                      ddb.update_item(
                          TableName=os.environ["TABLE_NAME"],
                          Key={"id": {"S": MAPPING_SET_KEY}},
                          UpdateExpression=update_expr,
                          ExpressionAttributeNames=expr_attr_names,
                          ExpressionAttributeValues=expr_attr_values,
                      )
                      logger.info("Updated bidirectional CliToMpc mapping: %s", cli_to_mpc)

                  # Step 2: Lookup mapping to get target ID → then lookup connectionId
                  source_id = body.get("sourceId")  # required to determine peer
                  if not source_id:
                      return {"statusCode": 400, "body": json.dumps({"error": "Missing SourceId"})}

                  # Fetch mapping
                  response = ddb.get_item(
                      TableName=os.environ["TABLE_NAME"],
                      Key={"id": {"S": MAPPING_SET_KEY}},
                      ProjectionExpression="mapping"
                  )
                  mapping = response.get("Item", {}).get("mapping", {}).get("M", {})

                  peer_id = mapping.get(source_id, {}).get("S")
                  if not peer_id:
                      return {"statusCode": 404, "body": json.dumps({"error": f"No peer found for {source_id}"})}
                  logger.info("Get peer_id: %s", peer_id)

                  # Fetch peer connectionId
                  conn_response = ddb.get_item(
                      TableName=os.environ["TABLE_NAME"],
                      Key={"id": {"S": CONNECTION_SET_KEY}},
                      ProjectionExpression="#items",
                      ExpressionAttributeNames={"#items": "items"}
                  )
                  connection_id = conn_response.get("Item", {}).get("items", {}).get("M", {}).get(peer_id, {}).get("S")
                  if not connection_id:
                      return {"statusCode": 404, "body": json.dumps({"error": f"No connectionId found for peer {peer_id}"})}
                  logger.info("Get connection_id: %s", connection_id)

                  # Step 3: Send message
                  domain = event["requestContext"]["domainName"]
                  stage = event["requestContext"]["stage"]
                  endpoint_url = f"https://{domain}/{stage}"
                  apigw = boto3.client("apigatewaymanagementapi", endpoint_url=endpoint_url)

                  payload = {
                      "operationType": operation_type,
                      "from": source_id,
                      "message": message
                  }

                  apigw.post_to_connection(
                      ConnectionId=connection_id,
                      Data=json.dumps(payload).encode("utf-8")
                  )
                  logger.info("Sent payload to %s: %s", peer_id, payload)
                  return {"statusCode": 200, "body": "Message sent successfully"}
              except Exception as e:
                  logger.error("sendServer failed: %s", e)
                  return {"statusCode": 500, "body": json.dumps({"error": str(e)})}
      Role: !GetAtt SendServerHandlerServiceRole.Arn
      Environment:
        Variables:
          TABLE_NAME: !Ref ConnectionsTable
      Handler: index.lambda_handler
      Runtime: python3.12
    DependsOn:
      - SendServerHandlerServiceRole
      - SendServerHandlerServiceRoleDefaultPolicy
  SendServerIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SendServerHandler.Arn}/invocations
      IntegrationMethod: POST
  SendServerRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: "sendServer"
      AuthorizationType: NONE
      Target: !Sub integrations/${SendServerIntegration}
  SendServerLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt SendServerHandler.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/sendServer

  PingHandlerServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: lambda.amazonaws.com
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  PingHandler:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |-
          import json
          import logging
          import boto3

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("Received event: %s", json.dumps(event))

              connection_id = event["requestContext"]["connectionId"]
              domain = event["requestContext"]["domainName"]
              stage = event["requestContext"]["stage"]

              apigw = boto3.client("apigatewaymanagementapi",
                                   endpoint_url=f"https://{domain}/{stage}")

              payload = {"action": "pong"}

              apigw.post_to_connection(
                  ConnectionId=connection_id,
                  Data=json.dumps(payload).encode("utf-8")
              )
              return {"statusCode": 200}
      Role: !GetAtt PingHandlerServiceRole.Arn
      Handler: index.lambda_handler
      Runtime: python3.12
      Timeout: 3
      MemorySize: 128
    DependsOn:
      - PingHandlerServiceRole
  PingIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref WebSocketApi
      IntegrationType: AWS_PROXY
      IntegrationUri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PingHandler.Arn}/invocations
      IntegrationMethod: POST
  PingRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref WebSocketApi
      RouteKey: "ping"
      AuthorizationType: NONE
      Target: !Sub integrations/${PingIntegration}
  PingLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt PingHandler.Arn
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${WebSocketApi}/*/ping

Outputs:
  ConnectHandlerFunction:
    Description: Lambda function for the $connect route of the WebSocket API
    Value: !GetAtt 'ConnectHandler.Arn'
  DisconnectHandlerFunction:
    Description: Lambda function for the $disconnect route of the WebSocket API
    Value: !GetAtt 'DisconnectHandler.Arn'
  WebSocketApiId:
    Description: "ID of the WebSocket API"
    Value: !Ref WebSocketApi
  WebSocketApiEndpoint:
    Description: "WebSocket API endpoint"
    Value: !Sub "wss://${WebSocketApi}.execute-api.${AWS::Region}.amazonaws.com/${StageName}"